/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	bzl "github.com/bazelbuild/buildtools/build"
)

var (
	// Generator tags are specified using the format "// +k8s:name=value"
	genTagRe = regexp.MustCompile(`//\s*\+k8s:([^\s=]+)(?:=(\S+))\s*\n`)
)

// tag name -> (pkg -> values)
type generatorTagsPkgMap map[string]map[string][]string

// walkGenerated generates the k8s codegen bzl file.
// This involves reading all non-test go sources in the tree and looking for
// "+k8s:name=value" tags. Only those tags listed in K8sCodegenTags will be
// included.
func (v *Vendorer) walkGenerated() (bool, error) {
	if v.cfg.K8sCodegenBzlFile == "" {
		return false, nil
	}
	// only include the specified tags
	requestedTags := make(map[string]bool)
	// tag name -> (pkg -> values)
	tagsPkgsValues := make(generatorTagsPkgMap)
	// tag name -> (tag value -> pkgs)
	tagsValuesPkgs := make(generatorTagsPkgMap)
	for _, tag := range v.cfg.K8sCodegenTags {
		requestedTags[tag] = true
	}
	err := v.findGeneratorTags(".", requestedTags, tagsPkgsValues, tagsValuesPkgs)
	if err != nil {
		return false, err
	}

	return v.createGeneratedBzlFile(tagsPkgsValues, tagsValuesPkgs)
}

// findGeneratorTags searches for all packages under root that include a kubernetes generator
// tag comment. It does not follow symlinks, and any path in the configured skippedPaths is skipped.
func (v *Vendorer) findGeneratorTags(root string, requestedTags map[string]bool, tagsPkgsValues, tagsValuesPkgs generatorTagsPkgMap) error {
	for _, r := range v.skippedK8sCodegenPaths {
		if r.MatchString(root) {
			return nil
		}
	}
	finfos, err := ioutil.ReadDir(root)
	if err != nil {
		return err
	}
	// map tag name -> set of values
	foundTags := make(map[string]map[string]bool)
	for _, finfo := range finfos {
		path := filepath.Join(root, finfo.Name())
		if finfo.IsDir() && (finfo.Mode()&os.ModeSymlink == 0) {
			err := v.findGeneratorTags(path, requestedTags, tagsPkgsValues, tagsValuesPkgs)
			if err != nil {
				return err
			}
			continue
		}
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			continue
		}

		b, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}
		matches := genTagRe.FindAllSubmatch(b, -1)
		for _, m := range matches {
			if len(m) >= 3 {
				tag, values := string(m[1]), string(m[2])
				if _, requested := requestedTags[tag]; !requested {
					continue
				}
				if _, present := foundTags[tag]; !present {
					foundTags[tag] = make(map[string]bool)
				}
				for _, v := range strings.Split(values, ",") {
					foundTags[tag][v] = true
				}
			}
		}
	}

	for tag, values := range foundTags {
		if _, present := tagsPkgsValues[tag]; !present {
			tagsPkgsValues[tag] = make(map[string][]string)
		}
		if _, present := tagsValuesPkgs[tag]; !present {
			tagsValuesPkgs[tag] = make(map[string][]string)
		}

		for v := range values {
			tagsPkgsValues[tag][root] = append(tagsPkgsValues[tag][root], v)
			tagsValuesPkgs[tag][v] = append(tagsValuesPkgs[tag][v], root)
		}
		sort.Strings(tagsPkgsValues[tag][root])
	}
	return nil
}

// createGeneratedBzlFile uses the maps created by findGeneratorTags to generate
// a bzl file that can be parsed by Skylark macros.
// If a K8sCodegenBoilerplateFile was configured, the contents of this file
// will be included as the header of the generated bzl file.
func (v *Vendorer) createGeneratedBzlFile(tagsPkgsValues, tagsValuesPkgs generatorTagsPkgMap) (bool, error) {
	f := &bzl.File{
		Path: v.cfg.K8sCodegenBzlFile,
	}
	addCommentBefore(f, "#################################################")
	addCommentBefore(f, "# # # # # # # # # # # # # # # # # # # # # # # # #")
	addCommentBefore(f, "This file is autogenerated by kazel. DO NOT EDIT.")
	addCommentBefore(f, "# # # # # # # # # # # # # # # # # # # # # # # # #")
	addCommentBefore(f, "#################################################")
	addCommentBefore(f, "")

	f.Stmt = append(f.Stmt, varExpr("go_prefix", "The go prefix passed to kazel", v.cfg.GoPrefix))
	f.Stmt = append(f.Stmt, varExpr("kazel_configured_tags", "The list of codegen tags kazel is configured to find", v.cfg.K8sCodegenTags))
	f.Stmt = append(f.Stmt, varExpr("tags_pkgs_values", "tags_pkgs_values is a dictionary mapping k8s build tag -> (pkgs -> tag values in pkg)", tagsPkgsValues))
	f.Stmt = append(f.Stmt, varExpr("tags_values_pkgs", "tags_values_pkgs is a dictionary mapping k8s build tag -> (tag values -> pkgs including that tag:value)", tagsValuesPkgs))

	var boilerplate []byte
	if v.cfg.K8sCodegenBoilerplateFile != "" {
		var err error
		boilerplate, err = ioutil.ReadFile(v.cfg.K8sCodegenBoilerplateFile)
		if err != nil {
			return false, err
		}
	}
	// Open existing file to use in diff mode.
	_, err := os.Stat(f.Path)
	if err != nil && !os.IsNotExist(err) {
		return false, err
	}
	return writeFile(f.Path, f, boilerplate, !os.IsNotExist(err), v.dryRun)
}
